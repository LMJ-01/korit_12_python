# 클래스
```python
'''
클래스 정의 형식:

class 클래스명(파스칼케이스):
    본문(attribute / method)

객체 생성 형식 :
객체명 = 클래스명()            # 생성자 호출은 맞는데 new가 없습니다.
'''
from copyreg import constructor


# 클래스 정의 예시
class WaffleMachine:
    pass                # 이거 클래스나 함수에 쓰면 엔터쳤을때 오류가 안남

# 객체 생성 예시
waffle = WaffleMachine()
print(waffle)   # 결과값 : <__main__.WaffleMachine object at 0x0000027A13F30590>
'''
클래스의 구성

1. 클래스의 기본 구성
    객체를 만들어내는 클래스는 객체가 가져야 할 구성 요소를 지닙니다(Java 떄 제가 방이 가져야 할 구성요소는 뭐였냐고 질문했었습니다). 객체를 생성하기 위해서는 객체가 가져야 할 '값'과 '기능'을 지녀야 합니다.
    
    값 = 속성(attribute)
    기능 = 메서드(method)
    
    클래스를 구성하는 속성은 두 가지로 나뉩니다.
        1) 클래스 변수 : 클래스를 기반으로 생성된 모든 인스턴스들이 공유하는 변수(Java에서는 얘를 static 변수라고 불렀습니다).
        2) 인스턴스 변수 : 인스턴스들이 개별적으로 가지는 변수
    메서드는 특징에 따라서
        1) 클래스 메서드
        2) 인스턴스 메서드
        3) 정적 메서드
    
    Java에서는 this 썼었는데(아직 정의 중인 클래스에 대한 객체가 생성될 수 없으니 임의로 this 키뤄드를 썼었습니다), python에서는 self 씁니다.
    
    self 키워드 : 인스턴스 변수에서 각각의 객체를 의미하기 위해서 self 키워드를 붙여줍니다. 인스턴스 메서드에서의 첫 번쨰 매개변수로 '항상' self를 추가해야합니다(그래서 자동 생성됩니다).
'''
# 클래스 정의
class Person:
    # 메서드 정의(함수가 클래스 내에 있으니까 / 들여쓰기 주의해야 합니다).
    def set_info(self, name, age, tel, address):
        self.name = name
        self.age = age
        self.tel = tel
        self.address = address

    def show_info(self):
        print(f'이름 :  {self.name}')
        print(f'나이 :  {self.age}')
        print(f'연락처 :  {self.tel}')
        print(f'주소 :  {self.address}')

    def show_info2(self):
        return f'제 이름은 {self.name}이고, {self.age}살입니다.\n연락처는 {self.tel}인데, {self.address}에 살고 있습니다.'

# 객체 생성
person1 = Person()
# Person 클래스의 인스턴스에 인스턴스 메서드 호출 -> 왜? 첫번쨰 매개변수가 self였으니까.
person1.set_info(age=20, tel='010-1234-5678', address='부산광역시 부산진구', name='김일')
# 이상의 코드에서 keyword argument를 썼습니다. 어떤 속성에 어떤 값을 넣는지 아니까 굳이 Java의 builer 패턴이 필요 없겠네요.
person1.show_info()
print(person1.show_info2())

# constructor 디렉토리 생성 -> main
```

# constructor

```python
'''
constructor -> main
아까 전에 일종의 setter 같은 것을 이용하여 속성에 속성값을 대입해줬습니다. 굳이 field 선언을 하지 않았는데 method 내에서 객체의 속성을 정의할 수 있다는 점이 특이했습니다. 그런데 이렇게 메서드를 경유하게 되면 기본 생성자를 통해서 객체를 생성한 다음에 속성에 값을 대입해야 하는 과정을 거쳐야 하는 것을 알 수 있습니다.

객체 생성시 기본 생성자 호출 -> set_info() 메서드 호출해서 값 대입

그러니까, AllArgsConstructor에 해당되는 걸 python에서 정의할 수 있지 않을까
'''
# 클래스 정의
class Candy:
    def set_info(self, shape, color):
        self.shape = shape
        self.color = color

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')

# 객체 생성 시 ( 기본 생성자 호출 -> set_info() 호출 -> show_info() 호출 )
satang = Candy()
satang.set_info('구형', '갈색')
satang.show_info()
'''
속성값에 대한 제한이 따로 있지 않다면(예를 들어 나이에 123098살을 입력하는 등의) 굳이 빈 객체 만들어놓고 거기에 값 대입하는 것이 비효율적으로 느껴집니다. 그래서 저희는 AllArgsConstructor를 도입할겁니다.

Java / JS에서의 생성자 명은 클래스 명과 동일하거나 constructor를 쓰는데, python만 또 지 혼자서 이상한거 씁니다. __init__() 입니다. 언더스코어 두 개임.
'''
class Candy2:
    # 생성자 정의
    def __init__(self, shape, color):
        self.shape = shape
        self.color = color
        print('사탕 객체가 생성되었습니다.')

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')
# 객체 생성 방식에서의 차이가 있습니다.
satang2 = Candy2(shape='정육면체', color='흰색')
satang2.show_info()
'''
소멸자
'''
class Sample:
    # 생성자 정의
    def __init__(self):
        print('인스턴스가 생성되었습니다.')

    # 소멸자 정의
    def __del__(self):
        print('인스턴스가 소멸되었습니다.')

# 객체 생성
sample = Sample()
print()
#객체 소멸자 호출 방법
del sample              # del 객체명입니다 소멸자는 객체 메모리를 날려야하기 때문에 객체에 종속이 아닙니다.
print('객체 소멸 이후 작성한 코드입니다. 프로그램 종료 전에 이미 객체가 삭제되었음을 확인할 수 있습니다.')
'''
지금 보니까 코드 다 돌아가면 객체가 소멸되는 것 같은데 굳이 소멸자를 학습하는 이유 -> 객체가 생성되면 메모리 공간을 차지하기 때문에 객체가 생성될 때마다 그곳에서 불려나오게 됩니다. 하지만 특정 객체가 일정 코드라인 이후로 전혀 사용되지 않을 때에도 여전히 메모리를 차지하기 때문에 소멸자를 통해서 강제로 객체를 삭제해주게 되면 메모리 관리가 된다고 볼 수 있습니다.

기본 예제

생성자를 이용해서 용량을 가진 usb 인스턴스를 만드는 프로그램을 작성하시오.

지시 사항
1. 클래스 USB를 정의할 것
2. 생성자를 정의하여 매개변수로 capacity를 받을 것
3. get_info() 메서드를 정의할 것

main 단계 코드
usb = USB(64)
usb.get_info()

실행 예
USB 객체가 생성되었습니다.
64GB USB 
'''
class USB:
    def __init__(self, capacity):
        self.capacity = capacity
        print('USB 객체가 생성되었습니다.')

    def get_info(self):
        print(f'{self.capacity}GB USB')

usb = USB(64)
usb.get_info()

class Person:
    def __init__(self, name):
        self.name = name
        print(f'{name} is born.')
    def __del__(self):
        print(f'{self.name} is dead')

man = Person('james')
woman = Person('emily')

del man
print('위 문장에서 man 객체 소멸시켰습니다.')

'''
emily id dead. 맨 마지막에 이 친구가 나오는 이유 -> 프로그램 종료할 때 원래 객체들 다 소멸시킵니다.
'''

```

# @property

```python
# student -> main
class Student:
    # 생성자 정의
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        # 성적을 저장하기 위한 빈 딕셔너리 -> 과목명을 key / 점수를 value로 예정
        self.grades = {}

    # python 버전의 getter에 해당하는 메서드 정의 방식
    @property
    def name(self):
        return self._name
    # python 버전의 setter의 예시
    @name.setter
    def name(self, value):
        self._name = value

# 객체 생성
student1 = Student('김일', 2026001)
# getter의 호출 - 주의 사항: 객체명.속성명도 아니고 객체명.메서드명() - 소괄호열고닫고가 아니라는 점에 주목해야 합니다.
print(f'학생 이름 : {student1.name}')
# setter 호출 예시
student1.name = '김영'
# getter 재호출
print(f'변경된 학생 이름 : {student1.name}')
print(student1._name)   # 속성명으로도 여전히 불러낼 수 있습니다.

'''
이상의 코드에서 확인 가능한 점은 Java 기준으로 python 코드를 해석할 떄 의문스러운 점이 많다는 점입니다.

1. _name이라는 속성이 있는데 객체명.name을 통해서 '김일' / '김영'이라는 속성값이 출력 된다는 점 : 그런데 객체명._name도 작동한다는 점

2. 객체명._name = '김영'이 아니라 객체명.name = '김영'으로 재대입한 것처럼 보이지 setter의 호출로 보이지 않는다는 점. 당연히 객체명.set_name("김영")이어야 하지 않냐는 의문점

입니다.

그런데 이건 Java 기준으로 본거고, python으로 풀었을 떄는, _name / name이 서로 다른 개념으로 보이지만 '_'가 붙으면 파이썬 언어 내부적으로 동일한 속성으로 처리해줍니다.

객체명. 속성명 뒤에 ()가 없음에도 불구하고 파이썬은 이걸 그냥 메서드처럼 처리해준다는 점입니다. 그래서 그냥 객체명.속성명이면 getter로 처리해주고 '객체명.속성명 = 데이터'면 알아서 setter로 처리해줍니다.

그런데 그 '알아서' 처리하기 위한 필수적인 작업이 '@property' 와 '속성명.setter'라는 데코레이터(decorator) 떄문입니다.

원래는 이거 자동 생성되기 떄문에 일일이 @ 달고 _속성명인지 / 그냥 속성명인지 따질 필요가 없는데 저희는 backend를 파이썬으로 짜지 않기 떄문에 현재 쓸모가 좀 없는 상황입니다. 현재 수준으로는 python으로 백엔드를 작성할 떄 필요할 떄가 있고, 이렇게 getter / setter를 쓴다는 것으로 알아두시면 되겠습니다.
'''
```

# constructor

```python
'''
constructor -> main
아까 전에 일종의 setter 같은 것을 이용하여 속성에 속성값을 대입해줬습니다. 굳이 field 선언을 하지 않았는데 method 내에서 객체의 속성을 정의할 수 있다는 점이 특이했습니다. 그런데 이렇게 메서드를 경유하게 되면 기본 생성자를 통해서 객체를 생성한 다음에 속성에 값을 대입해야 하는 과정을 거쳐야 하는 것을 알 수 있습니다.

객체 생성시 기본 생성자 호출 -> set_info() 메서드 호출해서 값 대입

그러니까, AllArgsConstructor에 해당되는 걸 python에서 정의할 수 있지 않을까
'''
# 클래스 정의
class Candy:
    def set_info(self, shape, color):
        self.shape = shape
        self.color = color

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')

# 객체 생성 시 ( 기본 생성자 호출 -> set_info() 호출 -> show_info() 호출 )
satang = Candy()
satang.set_info('구형', '갈색')
satang.show_info()
'''
속성값에 대한 제한이 따로 있지 않다면(예를 들어 나이에 123098살을 입력하는 등의) 굳이 빈 객체 만들어놓고 거기에 값 대입하는 것이 비효율적으로 느껴집니다. 그래서 저희는 AllArgsConstructor를 도입할겁니다.

Java / JS에서의 생성자 명은 클래스 명과 동일하거나 constructor를 쓰는데, python만 또 지 혼자서 이상한거 씁니다. __init__() 입니다. 언더스코어 두 개임.
'''
class Candy2:
    # 생성자 정의
    def __init__(self, shape, color):
        self.shape = shape
        self.color = color
        print('사탕 객체가 생성되었습니다.')

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')
# 객체 생성 방식에서의 차이가 있습니다.
satang2 = Candy2(shape='정육면체', color='흰색')
satang2.show_info()
'''
소멸자
'''
class Sample:
    # 생성자 정의
    def __init__(self):
        print('인스턴스가 생성되었습니다.')

    # 소멸자 정의
    def __del__(self):
        print('인스턴스가 소멸되었습니다.')

# 객체 생성
sample = Sample()
print()
#객체 소멸자 호출 방법
del sample              # del 객체명입니다 소멸자는 객체 메모리를 날려야하기 때문에 객체에 종속이 아닙니다.
print('객체 소멸 이후 작성한 코드입니다. 프로그램 종료 전에 이미 객체가 삭제되었음을 확인할 수 있습니다.')
'''
지금 보니까 코드 다 돌아가면 객체가 소멸되는 것 같은데 굳이 소멸자를 학습하는 이유 -> 객체가 생성되면 메모리 공간을 차지하기 때문에 객체가 생성될 때마다 그곳에서 불려나오게 됩니다. 하지만 특정 객체가 일정 코드라인 이후로 전혀 사용되지 않을 때에도 여전히 메모리를 차지하기 때문에 소멸자를 통해서 강제로 객체를 삭제해주게 되면 메모리 관리가 된다고 볼 수 있습니다.

기본 예제

생성자를 이용해서 용량을 가진 usb 인스턴스를 만드는 프로그램을 작성하시오.

지시 사항
1. 클래스 USB를 정의할 것
2. 생성자를 정의하여 매개변수로 capacity를 받을 것
3. get_info() 메서드를 정의할 것

main 단계 코드
usb = USB(64)
usb.get_info()

실행 예
USB 객체가 생성되었습니다.
64GB USB 
'''
class USB:
    def __init__(self, capacity):
        self.capacity = capacity
        print('USB 객체가 생성되었습니다.')

    def get_info(self):
        print(f'{self.capacity}GB USB')

usb = USB(64)
usb.get_info()

class Person:
    def __init__(self, name):
        self.name = name
        print(f'{name} is born.')
    def __del__(self):
        print(f'{self.name} is dead')

man = Person('james')
woman = Person('emily')

del man
print('위 문장에서 man 객체 소멸시켰습니다.')

'''
emily id dead. 맨 마지막에 이 친구가 나오는 이유 -> 프로그램 종료할 때 원래 객체들 다 소멸시킵니다.
'''

```

# class_static

```python
'''
1. 클래스 변수 vs. 인스턴스 변수
    인스턴스 변수 : 인스턴스 마다 서로 다른 값
    클래스 변수 : 모든 인스턴스가 동일한 값을 지니는 변수

    인스턴스 변수 접근 방식 - 인스턴스 접근(o) / 클래스 접근(x)
    클래스 변수 접근 방식 - 인스턴스 접근(o) / 클래스 접근(o)
'''


# 클래스 변수 예시
class Korean:
    country = '한국'  # 클래스 변수 # 1

    def __init__(self, name, age, address):
        self.name = name  # 인스턴스 변수 # 1
        self.age = age  # 인스턴스 변수 # 2
        self.address = address  # 인스턴스 변수 # 3


# 객체 생성
korean = Korean('김일', 21, '서울특별시 마포구')
print(korean.name)  # 인스턴스 변수 참조
# 클래스 변수 참조
print(korean.country)  # 객체명.클래스변수명 으로 접근 가능
print(Korean.country)  # 클래스명.클래스변수명 으로 접근 가능

'''
객체명.클래스변수명을 통해서 클래스 변수에 접근이 가능하긴 한데, 클래스 내부 코드를 보기 전까지는 country라는 변수가 인스턴스 변수인지 클래스 변수인지 알 방법이 없습니다.

이상을 이유로 클래스 변수를 확인하고자 할 때는 객체명.클래스변수명 보다는
클래스명.클래스변수명을 통해서 참조하는 것이 권장됩니다.

2. 클래스 메서드
'''


class Korean2:
    country = '대한민국'  # 클래스 변수의 선언 및 초기화

    # 클래스 메서드의 정의 방법
    @classmethod  # @ decorator를 달면 됩니다.
    def trip(cls, travelling_site):
        if cls.country == travelling_site:
            print('국내 여행입니다.')
        else:
            print('해외 여행입니다.')


# 클래스 메서드 호출
Korean2.trip('대한민국')
Korean2.trip('미국')
# 객체 생성
person2 = Korean2()
person2.trip('일본')  # 객체명.클래스메서드() 호출도 가능하긴 합니다. 근데 마찬가지로 권장되지 않습니다.

'''
3. 정적 메서드(static method)
    정적 메서드 또한 self를 쓰지 않음. 즉, 인스턴스 변수에 접근하여 사용하는 것이 불가능함을 의미. self.속성명을 사용하여 인스턴스 변수의 값을 참조하는데 정적 메서드는 아예 첫번째 매개변수가 고정되어 있지 않습니다. - 인스턴스변수를 참조하지 못한다는 점에서 클래스 메서드와의 공통점에 해당.

    인스턴스를 생성하지 않아도 사용할 수 있음 - 클래스 메서드와의 공통점 # 2

    특징 :
        1) 인스턴스 / 클래스로 호출 가능 -> 클래스 메서드와의 공통점
        2) 생성된 인스턴스가 없어도 호출 가능 -> 클래스 메서드와의 공통점

        3) @staticmethod 데코레이터를 표기하고 작성 -> 클래스 메서드와의 차이점 # 1
        4) 반드시 작성해야 하는 매개변수(self / cls)가 없음 -> 클래스 메서드와의 차이점 # 2

이상을 토대로 정적 메서드는 self/cls를 둘 다 사용하지 않기 때문에 인스턴스 / 클래스 변수를 모두 사용하지 않는 메서드를 정의하는 경우에 적합합니다.

즉, Java에서의 정적 메서드 = 파이썬의 클래스 메서드 + 정적 메서드
'''


class Korean3:
    country = '한국'

    @staticmethod
    def slogan():
        print('Imagine Your Korea ! 🎈')

    @staticmethod
    def slogan2(str_example):
        print(f'Imagine Your Korea ! 🎈 {str_example}')


# static method의 호출
Korean3.slogan()
Korean3.slogan2('근데 너무 춥다.')

'''
기본 예제
가방을 만들 때마다 현재 만들어진 가방이 몇 개인지 계산할 수 있는 Bag 클래스를 정의하겠습니다.
'''


class Bag:
    count = 0

    def __init__(self):  # 여기 내부나 인스턴스메서드 내부에서 self쓰면 속성이 선언되겠네요.
        Bag.count += 1  # cls.count가 아니라 Bag.count라는데에 주목해야합니다.
        # 즉, 생성자는 인스턴스 메서드이기 때문에 인스턴스 메서드 내에서 클래스 변수를 참조할 때는 cls.클래스변수명 이 아니라 클래스명.클래스변수명 으로 참조해야 한다는 점이 중요합니다.
        print('가방 객체가 생성되었습니다.')

    # 클래스 메서드의 정의
    @classmethod
    def sell(cls):
        print('가방이 팔렸습니다.')
        cls.count -= 1  # 얘는 클래스 메서드니까 Bag.count가 아니라 cls.count입니다.

    @classmethod
    def remain_bag(cls):
        return cls.count


# 객체 생성
bag1 = Bag()
print(
    f'현재 가방 재고 : {Bag.count}')  # 인스턴스메서드(생성자)를 통해서 클래스 변수의 값을 바꿨습니다. 이 값은 모든 Bag 클래스의 인스턴스들이 공유한다는 점에서 정적 변수 개념과 동일합니다.
bag2 = Bag()
bag3 = Bag()
print(f'현재 가방 재고 : {Bag.count}')
bag1.sell()  # 객체명.클래스메서드() 호출했습니다. - 실제로 bag1 객체가 소멸된건 아닙니다.
print(f'현재 가방 재고 : {Bag.count}')
'''
응용 예제
1. 다음 지시 사항을 읽고 이름과 전체 인구수를 저장할 수 있는 Person 클래스를 작성하시오.

지시 사항

1. 다음과 같은 방법으로 man과 woman 인스턴스를 생성하시오.
man = Person('김일')
woman = Person('김이')

2. man 과 woman 인스턴스가 생성되면 다음과 같은 메시지를 출력할 수 있도록 작성하시오.
김일이(가) 태어났습니다.
김이이(가) 태어났습니다.

3. 다음 코드를 통해서 전체 인구수를 조회할 수 있도록 작성하시오.
print(f'전체 인구수 : {Person.get_population()}')

4. 다음과 같은 명령어로 man 인스턴스를 삭제하시오.
del man

5. man 인스턴스가 삭제되면 다음과 같은 메시지를 출력할 수 있도록 소멸자를 정의하시오.
RIP 김일
'''

class Person:
    count = 0
    def __init__(self, name):
        self.name = name
        Person.count += 1
        print(f'{name}이(가) 태어났습니다.')


    @classmethod
    def get_population(cls):
        return cls.count

    def __del__(self):
        print(f'RIP {self.name}')
        Person.count -= 1


man = Person('김일')
woman = Person('김이')
print(f'전체 인구수 : {Person.get_population()}')

del man
print(f'전체 인구수 : {Person.get_population()}')
```

